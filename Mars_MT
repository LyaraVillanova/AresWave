import numpy as np
import matplotlib.pyplot as plt
from dsmpy import dsm_Mars, seismicmodel_Mars
from dsmpy.event_Mars import Event, MomentTensor
from dsmpy.station_Mars import Station
from obspy import read, UTCDateTime
from scipy.signal import correlate, butter, filtfilt
import glob
import os

# Definindo valores do evento
event_id = 'mqs2019kxjd'
name = 'S0185a'
latitude = 41.59816
longitude = 90.13083
depth_range = np.arange(5, 100, 5)  # Profundidade em km (busca em grade)
distance = 59.8
baz = 322.7
magnitude = 3.1

# Intervalos para a busca em grade dos parâmetros de falha
strike_range = np.arange(0, 360, 60)  # Variando de 0 a 360 graus com passo de 10
dip_range = np.arange(0, 90, 30)       # Variando de 0 a 90 graus com passo de 5
rake_range = np.arange(-180, 180, 60) # Variando de -180 a 180 graus com passo de 10

# Função para calcular o tensor de momento a partir da magnitude e dos parâmetros de falha
def calculate_moment_tensor(magnitude, strike, dip, rake):
    # Constante de momento sísmico (Mo)
    Mo = 10**((magnitude + 10.7) * 3 / 2)  # Calcula o momento sísmico
    
    # Convertendo os ângulos de graus para radianos
    strike_rad = np.radians(strike)
    dip_rad = np.radians(dip)
    rake_rad = np.radians(rake)

    # Cálculo do tensor de momento com base nos ângulos
    Mrr = Mo * (np.sin(dip_rad) * np.sin(2 * rake_rad))
    Mtt = -Mo * (np.sin(2 * dip_rad) * np.sin(rake_rad))
    Mpp = Mo * (np.sin(2 * dip_rad) * np.sin(rake_rad))
    Mrt = Mo * (np.cos(rake_rad) * np.sin(dip_rad))
    Mrp = Mo * (np.sin(rake_rad) * np.sin(2 * dip_rad))
    Mtp = -Mo * (np.sin(dip_rad) * np.sin(2 * strike_rad))

    print(f"Strike: {strike}, Dip: {dip}, Rake: {rake}")
    print(f"Tensor de Momento - Mrr: {Mrr}, Mrt: {Mrt}, Mrp: {Mrp}, Mtt: {Mtt}, Mtp: {Mtp}, Mpp: {Mpp}.")

    return MomentTensor(Mrr, Mrt, Mrp, Mtt, Mtp, Mpp)

# Tempos de chegada das ondas P e S
time_p = UTCDateTime("2019-06-05T02:13:50")
time_s = UTCDateTime("2019-06-05T02:19:34")
centroid_time = UTCDateTime((time_p.timestamp + time_s.timestamp) / 2)

# Estação
stations = [Station(name='ELYSE', network='XB', latitude=4.502384, longitude=135.623447)]

# Modelo sísmico e parâmetros de simulação
seismic_model = seismicmodel_Mars.SeismicModel.tayak()
tlen = 3276.8  # duração dos sintéticos
nspc = 256  # número de pontos no domínio da frequência
sampling_hz = 20  # frequência de amostragem

# Caminho para arquivos .sac
sac_folder_path = '/home/lyara/my_project/dsmpy-1/SAC'
sac_files = glob.glob(os.path.join(sac_folder_path, '*.sac'))
if not sac_files:
    raise FileNotFoundError(f"Nenhum arquivo .sac encontrado em {sac_folder_path}")

# Carregar dados reais
real_data_list = []
for sac_file in sac_files:
    real_data = read(sac_file)[0]
    real_data.detrend('linear')
    real_data.taper(max_percentage=0.05)
    real_data.resample(sampling_hz)
    real_data_list.append(real_data)

# Função para calcular variação entre sismogramas reais e sintéticos
def calculate_variation(real_data, synthetic_data):
    Mo = 10**((magnitude + 10.7) * 3 / 2)  #seismic moment
    min_len = min(len(real_data), len(synthetic_data))
    real_data = real_data[:min_len]
    synthetic_data = synthetic_data[:min_len]
    return np.sum((real_data - Mo*synthetic_data) ** 2)

# Função para aplicar filtro
def apply_filter(data, sampling_rate, cutoff_freq, filter_type='low'):
    nyquist = 0.5 * sampling_rate
    normal_cutoff = cutoff_freq / nyquist
    b, a = butter(4, normal_cutoff, btype=filter_type, analog=False)
    return filtfilt(b, a, data)

# Função para gerar sismogramas sintéticos
def generate_synthetics(event, seismic_model, stations):
    input = dsm_Mars.PyDSMInput.input_from_arrays(event, stations, seismic_model, tlen, nspc, sampling_hz)
    output = dsm_Mars.compute(input)
    output.to_time_domain()
    output.filter(freq=0.04)
    return output

# Busca em grade para encontrar os melhores parâmetros de falha (strike, dip, rake) e profundidade
min_variation = float('inf')
best_depth = None
best_strike = None
best_dip = None
best_rake = None
best_synthetic_data = None

for depth in depth_range:
    for strike in strike_range:
        for dip in dip_range:
            for rake in rake_range:
                # Calcular o tensor de momento para essa combinação de strike, dip e rake
                mt = calculate_moment_tensor(magnitude, strike, dip, rake)

                # Criar o evento com a profundidade e o tensor de momento calculados
                event = Event(
                    event_id=event_id,
                    latitude=latitude,
                    longitude=longitude,
                    depth=depth,
                    mt=mt,
                    centroid_time=centroid_time.timestamp,
                    source_time_function=None
                )

                # Gerar os sismogramas sintéticos
                output = generate_synthetics(event, seismic_model, stations)

                # Filtrar e comparar os dados sintéticos com os dados reais
                synthetic_data_Z = output['Z', 'ELYSE_XB']
                #synthetic_data_Z = apply_filter(synthetic_data_Z, sampling_hz, cutoff_freq=0.3)

                real_data_Z = real_data_list[0].data
                #real_data_Z = apply_filter(real_data_Z, sampling_hz, cutoff_freq=0.3)

                # Calcular a variação (diferença entre os dados sintéticos e reais)
                variation = calculate_variation(real_data_Z, synthetic_data_Z)

                # Se essa combinação de parâmetros gerar uma menor variação, atualizamos os melhores valores
                if variation < min_variation:
                    min_variation = variation
                    best_depth = depth
                    best_strike = strike
                    best_dip = dip
                    best_rake = rake
                    best_synthetic_data = synthetic_data_Z

                    print(f"Nova melhor variação: {variation}")
                    print(f"Melhor profundidade: {best_depth} km")
                    print(f"Melhor strike: {best_strike}, Melhor dip: {best_dip}, Melhor rake: {best_rake}")

print(f"Melhor profundidade estimada: {best_depth} km")
print(f"Melhores parâmetros de falha - Strike: {best_strike}, Dip: {best_dip}, Rake: {best_rake}")
print(f"Variação mínima: {min_variation}")
