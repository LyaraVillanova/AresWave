import numpy as np
from dsmpy.event_Mars import Event, MomentTensor
from dsmpy.station_Mars import Station
from obspy import read, UTCDateTime
from scipy.signal import correlate, butter, filtfilt

# Definindo valores do evento
event_id = 'mqs2019kxjd'
name = 'S0185a'
latitude = 41.59816
longitude = 90.13083
depth_range = np.arange(5, 100, 5)  # Profundidade em km (busca em grade)
distance = 59.8
baz = 322.7
magnitude = 3.1

# Tensor de Momento
Mrr = -2.8e12
Mrt = -1.9e13
Mrp = -1.3e13
Mtt = -1.4e13
Mtp = -5.3e12
Mpp = 1.8e13
mt = MomentTensor(Mrr, Mrt, Mrp, Mtt, Mtp, Mpp)

# Tempos de chegada das ondas P e S
time_p = UTCDateTime("2019-06-05T02:13:50")
time_s = UTCDateTime("2019-06-05T02:19:34")
centroid_time = UTCDateTime((time_p.timestamp + time_s.timestamp) / 2)

# Evento base
event_base = Event(
    event_id=event_id,
    latitude=latitude,
    longitude=longitude,
    depth=0,  # Placeholder, será atualizado
    mt=mt,
    centroid_time=centroid_time.timestamp,
    source_time_function=None
)

# Estação
stations = [Station(name='ELYSE', network='XB', latitude=4.502384, longitude=135.623447)]




def generate_synthetics(event, stations, seismic_model, tlen, nspc, sampling_hz):
    input = dsm_Mars.PyDSMInput.input_from_arrays(event, stations, seismic_model, tlen, nspc, sampling_hz)
    output = dsm_Mars.compute(input)
    output.to_time_domain()  # perform inverse FFT
    #output.filter(freq=0.04)  # apply a 25 seconds low-pass filter
    us = output.us  # synthetics. us.shape = (3,nr,tlen)
    ts = output.ts  # time points [0, tlen]
    return output

def apply_filter(data, sampling_rate, filter_type='bandpass'):
    nyquist = 0.5 * sampling_rate
    low = 0.3 / nyquist
    high = 0.9 / nyquist
    b, a = butter(4, [low, high], btype=filter_type, analog=False)
    return filtfilt(b, a, data)

# Função para aplicar filtro
def apply_filterl(data, sampling_rate, filter_type='low'):
    nyquist = 0.5 * sampling_rate
    normal_cutoff = 0.9 / nyquist
    b, a = butter(4, normal_cutoff, btype=filter_type, analog=False)
    return filtfilt(b, a, data)

def calculate_variation(real_data_PZ, synthetic_data_PZ, real_data_PR, synthetic_data_PR, 
                        real_data_SZ, synthetic_data_SZ, real_data_ST, synthetic_data_ST,
                        time_p, time_s, magnitude, sampling_rate, start_time, window_size=0.05):
    
    Mo = 10**((magnitude + 10.7) * 3 / 2)

    # Gerar o vetor de tempo baseado na taxa de amostragem e número de amostras
    n_amostras = len(real_data_PZ)  # Assumindo que todas as componentes têm o mesmo número de amostras
    intervalo_tempo = 1.0 / sampling_rate  # Intervalo de tempo entre pontos (segundos)
    time_vector = np.arange(0, n_amostras * intervalo_tempo, intervalo_tempo)

    # Converter time_p e time_s para segundos em relação ao start_time
    time_p_seconds = time_p - start_time
    time_s_seconds = time_s - start_time

    # Função auxiliar para detectar o índice de máxima amplitude próxima ao tempo esperado
    def find_wave_arrival(data, time_vector, time_expected, window_size):
        # Determinar o intervalo de tempo para busca
        start_idx = np.argmin(np.abs(time_vector - (time_expected - window_size)))
        end_idx = np.argmin(np.abs(time_vector - (time_expected + window_size)))
        # Encontrar o índice do valor máximo (ou mínimo) dentro da janela de busca
        arrival_idx = np.argmax(np.abs(data[start_idx:end_idx])) + start_idx
        return arrival_idx
    
    # Detectar chegada das ondas P e S nas componentes
    pz_idx = find_wave_arrival(real_data_PZ, time_vector, time_p_seconds, window_size)
    pr_idx = find_wave_arrival(real_data_PR, time_vector, time_p_seconds, window_size)
    sz_idx = find_wave_arrival(real_data_SZ, time_vector, time_s_seconds, window_size)
    st_idx = find_wave_arrival(real_data_ST, time_vector, time_s_seconds, window_size)

    variation_P = np.sum(
        1 * (
            (real_data_PZ[pz_idx] - Mo * synthetic_data_PZ[pz_idx]) ** 2 +
            (real_data_PR[pr_idx] - Mo * synthetic_data_PR[pr_idx]) ** 2
        )
    )

    variation_S = np.sum(
        1 * (
            (real_data_SZ[sz_idx] - Mo * synthetic_data_SZ[sz_idx]) ** 2 +
            (real_data_ST[st_idx] - Mo * synthetic_data_ST[st_idx]) ** 2
        )
    )
    total_variation = variation_P + variation_S
    return total_variation